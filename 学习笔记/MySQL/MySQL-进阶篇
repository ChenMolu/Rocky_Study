# MySQL-进阶篇

## 1. 存储引擎

### MySQL体系结构

![截屏2023-04-13 21.54.05](./image/MySQL-进阶篇/截屏2023-04-13 21.54.05.png)

- 连接层

  - 最上层是一些客户端和连接服务，主要完成一些类似于连接处理、授权认证、以及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。

* 服务层
  - 第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如存储过程、函数等。

* 引擎层
  - 存储引擎真正的负责了MySQL中数据的存储和提起，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。
* 存储层
  - 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。

### 存储引擎简介

> 和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。

存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎。

**建表时指定存储引擎：**

```sql
CREATE TABLE 表名(
字段1 字段1类型 [ COMMENT 字段1注释 ] ,
......
字段n 字段n类型 [COMMENT 字段n注释 ]
) ENGINE = INNODB [ COMMENT 表注释 ] ;
```

### InnoDB

介绍：InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在MySQL 5.5 之后，InnoDB是默认MySQL的存储引擎。

特点：

* DML操作遵循ACID模型，支持**事务**
* **行级锁**，提高并发访问性能
* 支持**外建** `FOREIGN KEY` 约束，保证数据的完整性和正确性。

文件：xxx.idb： xxx代表的是表名，InnoDB引擎的每张表都会对应这样一个**表空间文件**，存储该表的表结构（frm-早期,sdi-新版8.0)、数据和索引。

![截屏2023-04-17 19.48.03](./image/MySQL-进阶篇/结构.png)

- **表空间** : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以包含多个Segment段。
- **段** : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。
- **区** : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。
- **页** : 页是组成区的最小单元，页也是InnoDB存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。
- **行** : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段(后面会详细介绍)。

### MyISAM

介绍：MySQL早期默认的存储引擎

特点：

* 不支持事务，不支持外键
* 支持表锁，不支持行锁
* 访问速度快

文件：

- xxx.sdi：存储表结构信息
- xxx.MYD：存储数据
- xxx.MYI：存储索引

### Memory

介绍：

- Memory引擎的表数据是存放在内存中的，由于受到硬件问题或断电问题的影响，只能将这些表作为临时表或缓存使用。

特点：

- 内存存放
- hash索引（默认）

文件：

 xxx.sdi : 存储表结构信息

### 三者之间的区别

![截屏2023-04-17 19.55.27](./image/MySQL-进阶篇/截屏2023-04-17 19.55.27.png)

### 存储引擎选择

在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。

- **InnoDB:** 是Mysql的默认存储引擎，支持事务、外键、行级锁。如果应用对**事务的完整性**有比较高的要求，在并发条件下要求数据的**一致性**，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。
- MyISAM （被MongoDB取代）： 如果应用是**以读操作和插入操作为主**，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。（日志，电商足迹、评论等业务场景下）
- MEMORY（被Redis取代）：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。

## 2. 索引

### 2.1 索引概述

**介绍：**索引（index）是帮助`MySQL高效获取数据`的`数据结构(有序)`。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。

![截屏2023-04-18 16.08.22](./image/MySQL-进阶篇/截屏2023-04-18 16.08.22.png)

注：*只是示意图，并非真实索引结构*

#### 优缺点

优点：

* 提高数据检索的效率，降低数据库的IO成本
* 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。

缺点：

* 索引列也是要占用空间的。
* 索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低。 

### 2.2 索引结构

MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：

| 结构                | InnoDB   | MyISAM | Memory | 说明                                                         |
| ------------------- | -------- | ------ | ------ | ------------------------------------------------------------ |
| **B+Tree索引**      | 支持     | 支持   | 支持   | 最常见的索引类型，大部分引擎都支持 B+ 树索引                 |
| Hash索引            | 不支持   | 不支持 | 支持   | 底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不支持范围查询 |
| R-tree(空间索引）   | 不支持   | 支持   | 不支持 | 空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 |
| Full-text(全文索引) | 5.6+支持 | 支持   | 不支持 | 是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene,Solr,ES |

#### 二叉树

![截屏2023-04-18 16.26.13](./image/MySQL-进阶篇/截屏2023-04-18 16.26.13.png)

缺点：顺序插入时，会退化成单向链表，性能大大降低。数据量较大的情况下，二叉树的层级较深，检索数据速度慢。

同样红黑树，大数据量的情况下，层级较深，建所速度慢。 

#### B-Tree（`多路`平衡查找树）：

![截屏2023-04-18 16.30.14](./image/MySQL-进阶篇/截屏2023-04-18 16.30.14.png)

**特点：**

- 5阶的B-Tree，每一个节点最多存储4个key,对应5个指针。
- 一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。
- 在B-Tree中，非叶子节点和叶子节点都会存放数据

#### B+Tree：

![image-20220912114131057](./image/MySQL-进阶篇/e43eed1ed3c48bd03bd7517630ce6826.png)

*绿色框部分：索引部分，仅仅起到索引数据的作用，不存储数据*

*红色框部分：数据存储部分，在其叶子节点中要存储具体的数据*

**与B-Tree的区别：**

- 所有数据都会出现在叶子节点
- 叶子节点形成一个单向链表
- 非叶子节点仅仅起到索引数据的作用，具体数据都存放在叶子节点

> MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。

![image-20220912114152728](./image/MySQL-进阶篇/9873c7b509b6437c501a824f0192e7bf.png)

#### Hash

哈希索引就是采用一定的Hash算法，将键值换算成新的Hash值，映射到对应的槽位上，然后存储在Hash表中。

如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。

**特点：**

- Hash索引只能用于对等比较(=，in)，不支持范围查询（between，>，< ，…）
- 无法利用索引完成排序操作
- 查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+Tree索引

*在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。*

**为什么InnoDB存储引擎选择使用B+tree索引结构？**

* 相对于二叉树，层级更少，搜索效率更高
* 对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能下降。
* 相对Hash索引，B+tree支持范围匹配以及排序操作

### 2.3 索引分类

| 分类     | 含义                                                 | 特点                       | 关键字   |
| -------- | ---------------------------------------------------- | -------------------------- | -------- |
| 主键索引 | 针对于表中主键创建的索引                             | 默认自动创建，`只能有一个` | PRIMARY  |
| 唯一索引 | 避免同一个表中某数据列中的值重复                     | 可以有多个                 | UNIQUE   |
| 常规索引 | 快速定位特定数据                                     | 可以有多个                 |          |
| 全文索引 | 全文索引查找的是文本中的关键词，而不是比较索引中的值 | 可以有多个                 | FULLTEXT |

而在在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：

| 分类                        | 含义                                                         | 特点                |
| --------------------------- | ------------------------------------------------------------ | ------------------- |
| 聚簇索引(Clustered Index)   | 将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据   | 必须有,而且只有一个 |
| 非聚簇索引(Secondary Index) | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键值 | 可以有多个          |

聚簇索引选取规则：

- 如果存在主键，主键索引就是聚簇索引
- 如果不存在主键，将使用第一个唯一索引作为聚簇索引
- 如果表不存在主键或没有合适的唯一索引，则`InnoDB`会自动生成一个`rowid`作为隐藏的聚簇索引

聚簇索引和非聚簇索引的具体结构：

![image-20220912114225846](./image/MySQL-进阶篇/223cf67a65e57e2f2fe1d220de82671b.png)

- 聚集索引的叶子节点下挂的是这一行的数据。
- 二级索引的叶子节点下挂的是该字段值对应的主键值。

当执行`SELECT * FROM user WHERE name = 'arm'`时，查找过程如下：

![image-20220912114240819](./image/MySQL-进阶篇/874b9eabfa27269bcfb0ac8b2c561c49.png)

1. 由于是根据name字段进行查询，所以先根据name='Arm’到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm 对应的主键值 10。

2. 由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最 终找到10对应的行row。
3. 最终拿到这一行的数据，直接返回即可。

> 回表查询：这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方法，就称之为回表查询。

### 2.4 索引语法

### 2.5 SQL性能分析

#### SQL的执行频率

MySQL 客户端连接成功后，通过`show [session|global] status`命令可以提供服务器状态信 息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：

```sql
#session 是查看当前会话 ;
#global 是查询全局数据 ;
SHOW GLOBAL STATUS LIKE 'Com_______';
```

> 通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据 库优化提供参考依据。如果是以增删改为主，我们可以考虑不对其进行索引的优化。如果是以 查询为主，那么就要考虑对数据库的索引进行优化了。

#### 慢日志查询

慢查询日志记录了所有执行时间超过指定参数（`long_query_time`，单位：秒，默认10秒）的所有 SQL语句的日志。

#### PROFILE详情

show profiles能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。

```sql
#查看每一条SQL的耗时基本情况
SHOW PROFILES;

#查看指定query_id的SQL语句各个阶段的耗时
SHOW PROFILE FOR QUERY query_id;

#查看指定query_id的SQL语句CPU的使用情况
SHOW PROFILE CPU FOR QUERY query_id;
```

#### EXPLAIN执行计划

EXPLAIN或者DESC命令获取MySQL如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序。

```sql
#直接在select语句之前加上关键字 explain / desc
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;
```

### 2.6 索引使用

#### 最左前缀法则(联合索引)

如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始， 并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。

#### 范围查询

联合索引中，如果出现范围查询(>,<)，范围查询右侧的索引会失效。（尽量使用<=,>=符号）

#### 索引失效的情况

1. **索引列运算：**

   不要在索引列上进行运算操作，`索引将失效`。

   ```sql
   EXPLAIN SELECT * FROM tb_user WHERE SUBSTRING(phone,10,2) = '15'
   ```

2. **字符串不加引号**

   字符串类型字段使用时，不加引号，`索引将失效`。

   ```sql
   explain select * from tb_user where profession = '软件工程' and age = 31 and status
   = '0';
   
   explain select * from tb_user where profession = '软件工程' and age = 31 and status
   = 0;
   
   explain select * from tb_user where phone = '17799990015';
   
   explain select * from tb_user where phone = 17799990015;
   ```

3. **模糊查询**

   如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，`索引将失效`。

   ```sql
   explain select * from tb_user where profession like '软件%';#生效
   
   explain select * from tb_user where profession like '%工程';#失效
   
   explain select * from tb_user where profession like '%工%';#失效
   ```

4. **or连接的条件**

   用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。

   ```sql
   explain select * from tb_user where id = 10 or age = 23;
   
   explain select * from tb_user where phone = '17799990017' or age = 23;
   ```

   由于age没有索引，所以即使id、phone有索引，索引也会失效。所以需要针对于age也要建立索引。

5. **数据分布影响**

   如果MySQL优化器评估使用索引比全表更慢，则不使用索引。

   因为MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃 索引，走全表扫描。因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不如走全表扫描来的快，此时索引就会失效。

#### SQL提示

SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。



### 2.7 设计原则

1. 针对于数据量较大，且查询较为频繁的表建立索引。
2. 针对于常作为查询条件（WHERE）、排序（ORDER BY）、分组（GROUP BY）操作的字段建立索引。
3. 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。
4. 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。
5. 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。
6. 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。
7. 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询











