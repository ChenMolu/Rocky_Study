# Redis 缓存更新

缓存的**标准思路**就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，将查找到的数据加入到Redis中。

## 缓存更新的基本概念以及策略

缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。

### 缓存更新策略

- **内存淘汰：**redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)

- **超时剔除：**当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存
- **主动更新：**我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题

![](./image/Redis 缓存更新策略/1653322506393的副本.png)

## 缓存更新的不一致问题

由于我们的**缓存的数据源来自于数据库**,而数据库的**数据是会发生变化的**,因此,如果当数据库中**数据发生变化,而缓存却没有同步**,此时就会有**一致性问题存在**,其后果是:用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？

有如下几种方案

- Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案

- Read/Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理

- Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致

综合考虑使用方案一，如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来

* 删除缓存还是更新缓存？
  * 更新缓存：每次更新数据库都更新缓存，无效写操作较多
  * 删除缓存：更新数据库时让缓存失效，查询时再更新缓存

* 如何保证缓存与数据库的操作的同时成功或失败？
  * 单体系统，将缓存与数据库操作放在一个事务
  * 分布式系统，利用TCC等分布式事务方案

### 数据一致性的解决方案

![img](./image/Redis%20缓存更新策略/redis-shuju-yizhixing-537a505f-1f3f-4f23-b5e3-209c8c8a9281.png)

#### 1. 先写MySQL，再写Redis

![img](./image/Redis%20缓存更新策略/redis-shuju-yizhixing-9ac6e9ab-dd82-40a5-b71b-836c745ed8ac.png)

#### 2. 先写Redis，再写MySQL

![img](./image/Redis%20缓存更新策略/redis-shuju-yizhixing-c50e7ef0-40aa-4931-982a-a9aa31faa6f1.png)

#### 3. 先删除Redis，再写MySQL

![img](./image/Redis%20缓存更新策略/redis-shuju-yizhixing-0fec5605-5530-4b12-af0e-2b529c41e6e6.png)

#### 4. 先删除 Redis，再写 MySQL，再删除 Redis（缓存双删)

![img](./image/Redis%20缓存更新策略/redis-shuju-yizhixing-1fe439cd-83fe-487f-a7ba-578a84839616.png)

关于缓存第二次删除的解决方案有两种：

- 可以直接让A最后一个的缓存删除设置一个时间500ms（不太靠谱）
- **异步串行化删除，即删除请求入队列**

![img](./image/Redis%20缓存更新策略/redis-shuju-yizhixing-6cb3caf1-c85b-4361-8e29-9e71361fd0c8.png)

#### 5. 先写MySQL，再删除Redis（最推荐）

![img](./image/Redis%20缓存更新策略/redis-shuju-yizhixing-1f0e26a8-49c3-469e-a193-08f9766943aa.png)

对于不是强一致性要求的业务可以容忍。

#### 6. 先写 MySQL，通过 Binlog，异步更新 Redis

![img](./image/Redis%20缓存更新策略/redis-shuju-yizhixing-0da55874-8cf7-4c5a-995b-a0e6611bfac2.png)

这种方案，主要是监听 MySQL 的 Binlog，然后通过异步的方式，将数据更新到 Redis，这种方案有个前提，查询的请求，不会回写 Redis。这个方案，会保证 MySQL 和 Redis 的最终一致性，但是如果中途请求 B 需要查询数据，如果缓存无数据，就直接查 DB；如果缓存有数据，查询的数据也会存在不一致的情况。