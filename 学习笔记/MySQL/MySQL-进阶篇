# MySQL-进阶篇

## 1. 存储引擎

### MySQL体系结构

![截屏2023-04-13 21.54.05](./image/MySQL-进阶篇/截屏2023-04-13 21.54.05.png)

- 连接层

  - 最上层是一些客户端和连接服务，主要完成一些类似于连接处理、授权认证、以及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。

* 服务层
  - 第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如存储过程、函数等。

* 引擎层
  - 存储引擎真正的负责了MySQL中数据的存储和提起，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。
* 存储层
  - 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。

### 存储引擎简介

> 和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。

存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎。

**建表时指定存储引擎：**

```sql
CREATE TABLE 表名(
字段1 字段1类型 [ COMMENT 字段1注释 ] ,
......
字段n 字段n类型 [COMMENT 字段n注释 ]
) ENGINE = INNODB [ COMMENT 表注释 ] ;
```

### InnoDB

介绍：InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在MySQL 5.5 之后，InnoDB是默认MySQL的存储引擎。

特点：

* DML操作遵循ACID模型，支持**事务**
* **行级锁**，提高并发访问性能
* 支持**外建** `FOREIGN KEY` 约束，保证数据的完整性和正确性。

文件：xxx.idb： xxx代表的是表名，InnoDB引擎的每张表都会对应这样一个**表空间文件**，存储该表的表结构（frm-早期,sdi-新版8.0)、数据和索引。

![截屏2023-04-17 19.48.03](./image/MySQL-进阶篇/结构.png)

- **表空间** : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以包含多个Segment段。
- **段** : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。
- **区** : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。
- **页** : 页是组成区的最小单元，页也是InnoDB存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。
- **行** : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段(后面会详细介绍)。

### MyISAM

介绍：MySQL早期默认的存储引擎

特点：

* 不支持事务，不支持外键
* 支持表锁，不支持行锁
* 访问速度快

文件：

- xxx.sdi：存储表结构信息
- xxx.MYD：存储数据
- xxx.MYI：存储索引

### Memory

介绍：

- Memory引擎的表数据是存放在内存中的，由于受到硬件问题或断电问题的影响，只能将这些表作为临时表或缓存使用。

特点：

- 内存存放
- hash索引（默认）

文件：

 xxx.sdi : 存储表结构信息

### 三者之间的区别

![截屏2023-04-17 19.55.27](./image/MySQL-进阶篇/截屏2023-04-17 19.55.27.png)

### 存储引擎选择

在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。

- **InnoDB:** 是Mysql的默认存储引擎，支持事务、外键、行级锁。如果应用对**事务的完整性**有比较高的要求，在并发条件下要求数据的**一致性**，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。
- MyISAM （被MongoDB取代）： 如果应用是**以读操作和插入操作为主**，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。（日志，电商足迹、评论等业务场景下）
- MEMORY（被Redis取代）：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。

## 2. 索引

### 2.1 索引概述

**介绍：**索引（index）是帮助`MySQL高效获取数据`的`数据结构(有序)`。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。

![截屏2023-04-18 16.08.22](./image/MySQL-进阶篇/截屏2023-04-18 16.08.22.png)

注：*只是示意图，并非真实索引结构*

#### 优缺点

优点：

* 提高数据检索的效率，降低数据库的IO成本
* 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。

缺点：

* 索引列也是要占用空间的。
* 索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低。 

### 2.2 索引结构

MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：

| 结构                | InnoDB   | MyISAM | Memory | 说明                                                         |
| ------------------- | -------- | ------ | ------ | ------------------------------------------------------------ |
| **B+Tree索引**      | 支持     | 支持   | 支持   | 最常见的索引类型，大部分引擎都支持 B+ 树索引                 |
| Hash索引            | 不支持   | 不支持 | 支持   | 底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不支持范围查询 |
| R-tree(空间索引）   | 不支持   | 支持   | 不支持 | 空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 |
| Full-text(全文索引) | 5.6+支持 | 支持   | 不支持 | 是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene,Solr,ES |

#### 二叉树

![截屏2023-04-18 16.26.13](./image/MySQL-进阶篇/截屏2023-04-18 16.26.13.png)

缺点：顺序插入时，会退化成单向链表，性能大大降低。数据量较大的情况下，二叉树的层级较深，检索数据速度慢。

同样红黑树，大数据量的情况下，层级较深，建所速度慢。 

#### B-Tree（`多路`平衡查找树）：

![截屏2023-04-18 16.30.14](./image/MySQL-进阶篇/截屏2023-04-18 16.30.14.png)

**特点：**

- 5阶的B-Tree，每一个节点最多存储4个key,对应5个指针。
- 一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。
- 在B-Tree中，非叶子节点和叶子节点都会存放数据

#### B+Tree：

![image-20220912114131057](./image/MySQL-进阶篇/e43eed1ed3c48bd03bd7517630ce6826.png)

*绿色框部分：索引部分，仅仅起到索引数据的作用，不存储数据*

*红色框部分：数据存储部分，在其叶子节点中要存储具体的数据*

**与B-Tree的区别：**

- 所有数据都会出现在叶子节点
- 叶子节点形成一个单向链表
- 非叶子节点仅仅起到索引数据的作用，具体数据都存放在叶子节点

> MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。

![image-20220912114152728](./image/MySQL-进阶篇/9873c7b509b6437c501a824f0192e7bf.png)

#### Hash

哈希索引就是采用一定的Hash算法，将键值换算成新的Hash值，映射到对应的槽位上，然后存储在Hash表中。

如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。

**特点：**

- Hash索引只能用于对等比较(=，in)，不支持范围查询（between，>，< ，…）
- 无法利用索引完成排序操作
- 查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+Tree索引

*在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。*

**为什么InnoDB存储引擎选择使用B+tree索引结构？**

* 相对于二叉树，层级更少，搜索效率更高
* 对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能下降。
* 相对Hash索引，B+tree支持范围匹配以及排序操作

### 2.3 索引分类

| 分类     | 含义                                                 | 特点                       | 关键字   |
| -------- | ---------------------------------------------------- | -------------------------- | -------- |
| 主键索引 | 针对于表中主键创建的索引                             | 默认自动创建，`只能有一个` | PRIMARY  |
| 唯一索引 | 避免同一个表中某数据列中的值重复                     | 可以有多个                 | UNIQUE   |
| 常规索引 | 快速定位特定数据                                     | 可以有多个                 |          |
| 全文索引 | 全文索引查找的是文本中的关键词，而不是比较索引中的值 | 可以有多个                 | FULLTEXT |

而在在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：

| 分类                        | 含义                                                         | 特点                |
| --------------------------- | ------------------------------------------------------------ | ------------------- |
| 聚簇索引(Clustered Index)   | 将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据   | 必须有,而且只有一个 |
| 非聚簇索引(Secondary Index) | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键值 | 可以有多个          |

聚簇索引选取规则：

- 如果存在主键，主键索引就是聚簇索引
- 如果不存在主键，将使用第一个唯一索引作为聚簇索引
- 如果表不存在主键或没有合适的唯一索引，则`InnoDB`会自动生成一个`rowid`作为隐藏的聚簇索引

聚簇索引和非聚簇索引的具体结构：

![image-20220912114225846](./image/MySQL-进阶篇/223cf67a65e57e2f2fe1d220de82671b.png)

- 聚集索引的叶子节点下挂的是这一行的数据。
- 二级索引的叶子节点下挂的是该字段值对应的主键值。

当执行`SELECT * FROM user WHERE name = 'arm'`时，查找过程如下：

![image-20220912114240819](./image/MySQL-进阶篇/874b9eabfa27269bcfb0ac8b2c561c49.png)

1. 由于是根据name字段进行查询，所以先根据name='Arm’到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm 对应的主键值 10。

2. 由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最 终找到10对应的行row。
3. 最终拿到这一行的数据，直接返回即可。

> 回表查询：这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方法，就称之为回表查询。

### 2.4 索引语法

创建语法

```sql
CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (index_column_name,...);
```

查看索引

```sql
SHOW INDEX FROM table_name;
```

删除索引

```sql
DROP INDEX index_name ON table_name;
```

 

### 2.5 SQL性能分析

#### SQL的执行频率

MySQL 客户端连接成功后，通过`show [session|global] status`命令可以提供服务器状态信 息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：

```sql
#session 是查看当前会话 ;
#global 是查询全局数据 ;
SHOW GLOBAL STATUS LIKE 'Com_______';
```

> 通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据 库优化提供参考依据。如果是以增删改为主，我们可以考虑不对其进行索引的优化。如果是以 查询为主，那么就要考虑对数据库的索引进行优化了。

#### 慢日志查询

慢查询日志记录了所有执行时间超过指定参数（`long_query_time`，单位：秒，默认10秒）的所有 SQL语句的日志。

#### PROFILE详情

show profiles能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。

```sql
#查看每一条SQL的耗时基本情况
SHOW PROFILES;

#查看指定query_id的SQL语句各个阶段的耗时
SHOW PROFILE FOR QUERY query_id;

#查看指定query_id的SQL语句CPU的使用情况
SHOW PROFILE CPU FOR QUERY query_id;
```

#### EXPLAIN执行计划

EXPLAIN或者DESC命令获取MySQL如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序。

```sql
#直接在select语句之前加上关键字 explain / desc
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;
```

### 2.6 索引使用

#### 最左前缀法则(联合索引)

如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始， 并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。

#### 范围查询

联合索引中，如果出现范围查询(>,<)，范围查询右侧的索引会失效。（尽量使用<=,>=符号）

#### 索引失效的情况

1. **索引列运算：**

   不要在索引列上进行运算操作，`索引将失效`。

   ```sql
   EXPLAIN SELECT * FROM tb_user WHERE SUBSTRING(phone,10,2) = '15'
   ```

2. **字符串不加引号**

   字符串类型字段使用时，不加引号，`索引将失效`。

   ```sql
   explain select * from tb_user where profession = '软件工程' and age = 31 and status
   = '0';
   
   explain select * from tb_user where profession = '软件工程' and age = 31 and status
   = 0;
   
   explain select * from tb_user where phone = '17799990015';
   
   explain select * from tb_user where phone = 17799990015;
   ```

3. **模糊查询**

   如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，`索引将失效`。

   ```sql
   explain select * from tb_user where profession like '软件%';#生效
   
   explain select * from tb_user where profession like '%工程';#失效
   
   explain select * from tb_user where profession like '%工%';#失效
   ```

4. **or连接的条件**

   用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。

   ```sql
   explain select * from tb_user where id = 10 or age = 23;
   
   explain select * from tb_user where phone = '17799990017' or age = 23;
   ```

   由于age没有索引，所以即使id、phone有索引，索引也会失效。所以需要针对于age也要建立索引。

5. **数据分布影响**

   如果MySQL优化器评估使用索引比全表更慢，则不使用索引。

   因为MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃 索引，走全表扫描。因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不如走全表扫描来的快，此时索引就会失效。

#### SQL提示

SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。



### 2.7 设计原则

1. 针对于数据量较大，且查询较为频繁的表建立索引。
2. 针对于常作为**查询条件（WHERE）**、排序（ORDER BY）、分组（GROUP BY）操作的字段建立索引。
3. 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。
4. 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。
5. 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。
6. 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。
7. 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询

## 3. SQL优化

### 插入数据

普通插入：

1. 采用批量插入（一次插入的数据不建议超过1000条）

```sql
#批量插入数据
Insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry');
```

2. 手动提交事务

```sql
#手动控制事务的提交

start transaction;
insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry');
insert into tb_test values(4,'Tom'),(5,'Cat'),(6,'Jerry');
insert into tb_test values(7,'Tom'),(8,'Cat'),(9,'Jerry');
commit;
```

3. 主键顺序插入

```sql
#主键顺序插入，性能要高于乱序插入

主键乱序插入 : 8 1 9 21 88 2 4 15 89 5 7 3
主键顺序插入 : 1 2 3 4 5 7 8 9 15 21 88 89
```

**大批量插入：**
如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的**`load`**指令插入。

```mysql
# 客户端连接服务端时，加上参数 --local-infile（这一行在bash/cmd界面输入）
mysql --local-infile -u root -p
# 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关
set global local_infile = 1;
select @@local_infile;
# 执行load指令将准备好的数据，加载到表结构中
load data local infile '/root/sql1.log' into table 'tb_user' fields terminated by ',' lines terminated by '\n';
```

### 主键优化

数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT）

**页分裂：**页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。
**页合并：**当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。

![keySort](./image/MySQL-进阶篇/keySort.png)

MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定

> 文字说明不够清晰明了，具体可以看视频里的PPT演示过程：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90

**主键设计原则：**

- 满足业务需求的情况下，尽量降低主键的长度
- 插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键
- 尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号
- 业务操作时，避免对主键的修改

### order by优化

1. Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序
2. Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高

几种特殊情况：

如果order by字段全部使用升序排序或者降序排序，则都会走索引；

但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是`Using index, Using filesort`；

如果要优化掉Using filesort，则需要另外再创建一个索引，如：`create index idx_user_age_phone_ad on tb_user(age asc, phone desc);`，此时使用`select id, age, phone from tb_user order by age asc, phone desc;`会全部走索引

总结：

- 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则
- 尽量使用覆盖索引
- 多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）
- 如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）

### group by优化

- 在分组操作时，可以通过索引来提高效率
- 分组操作时，索引的使用也是满足**最左前缀法则**的

如索引为`idx_user_pro_age_stat`，则句式可以是`select ... where profession order by age`，这样也符合最左前缀法则

### limit优化

常见的问题如`limit 2000000, 10`，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。
优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过**覆盖索引加子查询形式**进行优化

例如：

```mysql
-- 此语句耗时很长
select * from tb_sku limit 9000000, 10;
-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询
select id from tb_sku order by id limit 9000000, 10;
-- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit
-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);
-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度
select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id;
```

### count优化

MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(\*) 的时候会直接返回这个数，效率很高（前提是不适用where）；
InnoDB 在执行 count(\*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。
*优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis*

count的几种用法：

- 如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值
- 用法：count(\*)、count(主键)、count(字段)、count(1)
- count(主键)跟count(\*)一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count(\*)一样；count(null)返回0

**各种用法的性能：**

- count(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空）
- count(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加
- count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加
- count(\*)：InnoDB 引擎并不会把全部字段取出来，而是**专门做了优化**，不取值，服务层直接按行进行累加

**按效率排序：**

count(字段) < count(主键) < count(1) < count(\*)，所以**尽量使用 count(\*)**

### update优化（避免行锁升级为表锁）

InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。

如以下两条语句：
```sql
`update student set no = '123' where id = 1;` // 这句由于id有主键索引，所以只会锁这一行；
`update student set no = '123' where name = 'test';`// 这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引
```

## 4. 视图

视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。  
通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。  

### 创建视图

`CREATE [ OR REPLACE ] VIEW 视图名称[（列名列表）] AS SELECT 语句 [ WITH [ CASCADED | LOCAL ] CHECK OPTION ]`  

> 例子： ` create or replace view stu_wll as select id,name from student where id<=10; `

### 查询视图

查看创建视图语句： `SHOW CREATE VIEW `视图名称；  

查看视图数据：`SELECT*FROM ` 视图名称；  
`show create view stu_v_1;`

### 修改视图

方式一：`CREATE[OR REPLACE] VIEW 视图名称[（列名列表)）] AS SELECT 语句[ WITH[ CASCADED | LOCAL ] CHECK OPTION ]`

方式二：`ALTER VIEW 视图名称 [（列名列表)] AS SELECT语句 [WITH [CASCADED | LOCAL] CHECK OPTION]`

### 删除视图

`DROP VIEW [IF EXISTS] 视图名称 [视图名称]`

### 视图检查选项

当使用`WITH CHECK QPTION`子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如插入，更新，删除，以使其符合视图的定义。MySQL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql提供了两个选项：CASCADED 和 LOCAL ，默认值为 CASCADED。

NOTE：如果没有开检查选项就不会进行检查。不同版本是不同含义的，要看版本。

#### CASCADED

`级联，一旦选择了这个选项，除了会检查创建视图时候的条件，还会检查所依赖视图的条件。`

> 比如下面的例子：创建stu_V_l 视图，id是小于等于 20的。  
> `create or replace view stu_V_l as select id,name from student where id <=20;`
> 再创建 stu_v_2 视图，20 >= id >=10。  
> `create or replace view stu_v_2 as select id,name from stu_v_1 where id >=10 with cascaded check option;`
> 再创建 stu_v_3 视图。     
> `create or replace view stu_v_3 as select id,name from stu_v_2 where id<=15;`  
> 这条数据能够成功，stu_v_3 没有开检查选项所以不会 去判断 id 是否小于等于15, 直接检查 是否满足 stu_v_2。  
> `insert into stu_v_3 values(17,'Tom');`

#### LOCAL

本地的条件也会检查，还会向上检查。在向上找的时候，就要看是否上面开了检查选项，如果没开就不检查。和 CASCADED 的区别就是 CASCADED 不管上面开没开检查选项都会进行检查。

### 更新及作用

要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新

1. 聚合函数或窗口函数 ( SUM()、MIN()、MAX()、COUNT() 等 )
2. DISTINCT
3. GROUP BY
4. HAVING
5. UNION 或者UNION ALL

例子： 

```sql 
使用了聚合函数，插入会失败。
create view stu_v_count as select count(*) from student;
insert into stu_v_count values(10);
```

**作用**

1. 简单

   视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。 

2. 安全
   数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据  
3. 数据独立
   视图可帮助用户屏蔽真实表结构变化带来的影响。  

总而言之 类似于给表加上了一个外壳，通过这个外壳访问表的时候，只能按照所设计的方式进行访问与更新。

## 5. 存储过程（TODO）

存储过程是事先经过编译并存储在数据库中的一段SQL 语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。
*存储过程思想上很简单，就是数据库SQL 语言层面的代码封装与重用。*

特点:

1. 封装
2. 复用
3. 可以接收参数，也可以返回数据减少网络交互，效率提升

### 创建

```sql
CREATE PROCEDURE 存储过程名称( [参数列表] ) 
BEGIN
	 SQL 语句 
END;
```

> 注意：在命令行中创建存储过程时，需要通过关键字DELIMITER指定一个结束符以提示；

### 调用

```sql
CALL 名称 ( [参数])
```

### 查看

```sql
// 查询指定数据库的存储过程及状态信息
SELECT* FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = 'xxx' 
// 存储过程名称；--查询某个存储过程的定义
SHOW CREATE PROCEDURE
```

### 删除

```sql
DROP PROCEDURE [ IFEXISTS ] 存储过程名称
```

### 游标

游标`（CURSOR）`是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH和CLOSE，其语法分别如下。

  **声明游标：**

```sql
DECLARE 游标名称 CURSOR FOR 查询语句
```

**打开游标：**

```sql
OPEN 游标名称
```

**获取游标记录：**

```sql
FETCH 游标名称INTO变量[变量]
```

**条件处理程序：** 

条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。

```sql
DELCARE handle_action HANDLER FOR condition_value [,condition_value]... statment;

handler_action
	CONTINUE：继续执行当前程序
	EXIT：终止执行当前程序
condition_value
	SQLSTATE sqlstate_value：状态码，如02000
	SQLWARNING：所有以01开头的SQLSTATE代码的简写
	NOT FOUND：所有以02开头的SQLSTATE代码的简写
	SQLEXCEPTION：所有没有呗SQLWARING 或 NOT FOUND捕获的SQLSTATE代码的简写
```

**实例：**

要求：

```text
根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名（name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表（id，name，profession）中。
```



```sql
create procedure p1l(in uage int)
	begin
		declare uname varchar(100); 
		decLare upro varchar(100);
		declare u_cursor cursor for select name,profession from tb_user where age <= uage; 
		当 条件处理程序的处理的状态码为02000的时候，就会退出。
		declare exit handler for SQLSTATE '02000'close u_cursor;
		
		drop table if exists tb_user_pro; 
		create table if not exists tb_user_pro(
      id int primary key auto_increment, 
      name varchar(100), 
      profession varchar(100)
		);

		open u_cursor; 
		while true do 
			fetch u_cursor into uname,Upro; 
			insert into tb_user_pro values(null,uname,Upro); 
		end while; 
		close u_cursor; 
	end;
```

### 存储函数

存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的。

语法：

```sql
CREATE FUNCTION 存储函数名称([参数列表])
RETURNS type [characteristic ...]
BEGIN
	[SQL语句...]
	RETURN ...;
END;

characteristic：
    DETERMINISTIC：相同的输入参数总是产生相同的结果
    NOSQL：不包含SQL语句
    READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句
```

### 触发器

**介绍 ：**

触发器是与表有关的数据库对象，指在`insert/update/delete`之前(BEFORE)或之后(AFTER)，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性,日志记录,数据校验等操作 。

使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还

只支持行级触发，不支持语句级触发。触发器类型如下：

| 触发器类型 | NEW 和 OLD                                           |
| ---------- | ---------------------------------------------------- |
| INSERT     | NEW 表示将要或者已经新增的数据                       |
| UPDATE     | OLD表示修改之前的数据，NEW表示将要或已经修改后的数据 |
| DELETE     | OLD表示将要或者已经删除的数据                        |

```sql
#创建触发器
CREATE TRIGGER trigger_name
BEFORE/AFTER INSERT/UPDATE/DELETE ON table_name FOR EACH ROW #行级触发器
BEGIN
 	trigger_stmt;
END;

#查看触发器
SHOW TRIGGERS;

#删除触发器
DROP TRIGGER [schema_name.]trigger_name;
```

## 6. 锁（TODO❗️）

**锁**是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。

> 针对事物才有加锁的意义。

MySQL中的锁，按照**锁的粒度**分，分为以下三类：

1. 全局锁：锁定数据库中的所有表。
2. 表级锁：每次操作锁住整张表。 
3. 行级锁：每次操作锁住对应的行数据。

### 全局锁：（TODO）

全局锁就是对**整个数据库实例加锁**，加锁后整个实例就处于**只读状态**，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。

**特点：**

1. 如果在主库上进行加全局锁备份，那么在备份期间都不能执行更新，业务基本无法正常进行。
2. 如果在从库上进行加全局锁备份，那么在备份期间从库就无法与主库进行同步，会导致主从不同步。

其典型的使用场景是做**全库的逻辑备份**，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。  

![截屏2023-04-21 16.29.04](./image/MySQL-进阶篇/截屏2023-04-21 16.29.04.png)

**语法：**

```sql
#加锁
FLUSH TABLES WITH READ LOCK;
#数据全局备份
MYSQLDUMP -uusername -ppassword database > filename.sql
#释放锁
UNLOCK TABLES;
```

<u>在InnoDB引擎中，可以在备份时加上`--single-transaction`参数来完成不加锁的一致性备份。</u>

### 表锁：

表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。*应用在MyISAM、InnoDB、BDB等存储引擎中。*  

对于表级锁，主要分为以下三类：

1. **表锁：**对于表锁，分为两类：

   * 表共享读锁（read lock）所有的事物都只能读（当前加锁的客户端也只能读，不能写），不能写 

   * 表独占写锁（write lock），对当前加锁的客户端，可读可写，对于其他的客户端，不可读也不可写。 
     读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。

2. **元数据锁（meta data lock，MDL）**，MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。**为了避免DML和DDL冲突，保证读写的正确性。**

   在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，**加MDL读锁（共享）**;当对表结构进行变更操作的时候，加**MDL写锁（排他）。**  

   | 对应SQL                                    | 锁类型                                | 说明                                             |
   | ------------------------------------------ | ------------------------------------- | ------------------------------------------------ |
   | LOCK TABLES … READ/WRITE                   | SHARED_READ_ONLY/SHARED_NO_READ_WRITE |                                                  |
   | SELECT、SELECT … LOCK IN SHARE MODE        | SHARED_READ                           | 与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥 |
   | NSERT、UPDATE、DELETE、SELECT … FOR UPDATE | SHARED_WRITE                          | 与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥 |
   | ALTER TABLE …                              | EXCLUSIVE                             | 与其他的MDL都互斥                                |

3. **意向锁:** 为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。 
   一个客户端对某一行加上了行锁，那么系统也会对其加上一个意向锁，当别的客户端来想要对其加上表锁时，便会检查意向锁是否兼容，若是不兼容，便会阻塞直到意向锁释放。  

**意向锁兼容性：**

1. 意向共享锁（IS）：与表锁共享锁（read）兼容，与表锁排它锁（write）互斥。  
2. 意向排他锁（lX）：与表锁共享锁（read）及排它锁（write）都互斥。意向锁之间不会互斥。  

### 行锁：

行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。**应用在InnoDB存储引擎中。** 
InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。

对于行级锁，主要分为以下三类：  

1. **行锁（Record Lock）：**锁定单个行记录的锁，**防止其他事务对此行进行update和delete**。在RC（read commit ）、RR（repeat read）隔离级别下都支持。  
2. **间隙锁（GapLock）：**锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。比如说 两个临近叶子节点为 15 23，那么间隙就是指 [15 , 23],锁的是这个间隙。
3. **临键锁（Next-Key Lock）：**行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。

InnoDB实现了以下两种类型的**行锁**：  

1. 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。
2. 排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。

| SQL                          | 行锁类型   | 说明                                     |
| ---------------------------- | ---------- | ---------------------------------------- |
| insert                       | 排他锁     | 自动加锁                                 |
| update                       | 排他锁     | 自动加锁                                 |
| delete                       | 排他锁     | 自动加锁                                 |
| select                       | 不加任何锁 |                                          |
| select　lock　in　share mode | 排他锁     | 需要手动在SELECT之后加LOCK IN SHARE MODE |
| select　for　update          | 排他锁     | 需要手动在SELECT之后加FOR UPDATE         |

行锁 - 演示  

默认情况下，InnoDB在REPEATABLE READ事务隔离级别运行，InnoDB使用next-key 锁进行搜索和索引扫描，以防止幻读。

1. 针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。
2. InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。

间隙锁/临键锁-演示

默认情况下，InnoDB在REPEATABLE READ事务隔离级别运行，InnoDB使用next-key 锁进行搜索和索引扫描，以防止幻读。

1. 索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁。
2. 索引上的等值查询（普通索引），向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。
3. 索引上的范围查询（唯一索引），会访问到不满足条件的第一个值为止。

*注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。*

## 7. InnoDB引擎

### 逻辑存储结构

再次回顾，InnoDB的逻辑存储结构如下所示：![截屏2023-04-22 16.17.31](./image/MySQL-进阶篇/截屏2023-04-22 16.17.31.png)

### 架构

MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。

![image-20220914095501600](./image/MySQL-进阶篇/c5d4c9892ae85ed35ad696811092b194.png)

#### 内存结构：

在左侧的内存结构中，主要分为四大块： `Buffer Pool、Change Buffer、AdaptiveHash Index、Log Buffer`。 接下来介绍一下这四个部分。

1. Buffer Pool（缓冲池）：

![截屏2023-04-22 16.23.10](./image/MySQL-进阶篇/截屏2023-04-22 16.23.10.png)

2.  Change Buffer（更改缓冲区）：

![截屏2023-04-22 16.25.03](./image/MySQL-进阶篇/截屏2023-04-22 16.25.03.png)

3. Adaptive Hash Index(自适应hash索引)：

![截屏2023-04-22 16.30.09](./image/MySQL-进阶篇/截屏2023-04-22 16.30.09.png)

4. Log Buffer（日志缓冲区）：

![截屏2023-04-22 16.32.27](./image/MySQL-进阶篇/截屏2023-04-22 16.32.27.png)

#### 磁盘结构：

**System Tablespace & File-Per-Table Tablespace:**

![截屏2023-04-22 16.40.50](./image/MySQL-进阶篇/截屏2023-04-22 16.40.50.png)

**General Tablesapce & Undo Tablesapce & Temporary Tablesapce：**

![截屏2023-04-22 16.44.13](./image/MySQL-进阶篇/截屏2023-04-22 16.44.13.png)

**Doublewrite Buffer Files & Redo Log :**

![截屏2023-04-22 16.59.28](./image/MySQL-进阶篇/截屏2023-04-22 16.59.28.png)

#### 后台线程：

![截屏2023-04-22 17.04.16](./image/MySQL-进阶篇/截屏2023-04-22 17.04.16.png)

**InnoDB的整个体系结构为：**

当业务操作的时候直接操作的是内存缓冲区，如果缓冲区当中没有数据，则会从磁盘中加载到缓冲区，增删改查都是在缓冲区的，后台线程以一定的速率刷新到磁盘。

### 事务原理

**事务**是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作**要么同时成功，要么同时失败**。

事务有**四大特性ACID**分别是：

- 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。
- 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。
- 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。
- 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。

而对于这四大特性，实际上分为两个部分： 

其中的**原子性、一致性、持久化**，实际上是由InnoDB中的两份日志来保证的，一份是`redo log`日志，一份`undo log`日志。 

而**持久性**是通过数据库的锁，加上MVCC来保证的。

![截屏2023-04-22 17.07.16](./image/MySQL-进阶篇/截屏2023-04-22 17.07.16.png)

#### REDO LOG（持久性）-- 为了将修改的数据持久化到磁盘中

重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。

该日志文件由两部分组成：`重做日志缓冲（redo log buffer）`以及`重做日志文件（redo logfile）`,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。

> 那为什么每一次提交事务，要刷新redo log到磁盘中呢，而不是直接将buffer pool中的脏页刷新到磁盘呢 ? 

因为在业务操作中，我们操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。而redo log在往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。这种先写日志的方式，称之为`WAL（Write-Ahead Logging）`。

#### UNDO LOG（原子性）

 回滚日志，用于记录数据被修改前的信息,作用包含两个:**提供回滚(保证事务的原子性)**和**MVCC(多版本并发控制)** 。

`undo log`和`redo log`记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，`undolog`中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。
`Undo log销毁`：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。

`Undo log存储`：undo log采用段的方式进行管理和记录，存放在rollback segment回滚段中，内部包含1024个undo log segment。

### MVCC

*作用：在事务修改数据时到底取哪个版本的数据内容。*

#### 基础概念

**当前读:**

读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：

* select...lock in share mode（共享锁）。
* select..…for update、update、insert、delete（排他锁）都是一种当前读。

**快照读:**

简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。

* Read Committed：每次select，都生成一个快照读。
* Repeatable Read：开启事务后第一个select语句才是快照读的地方。
* Serializable：快照读会退化为当前读。

#### 实现原理

MVCC全称``Multi-Version Concurrency Control`，**多版本并发控制**。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的**三个隐式字段、undo log日志、readView**。

**三个隐式字段：**

| 字段        | 含义                                                         |
| ----------- | ------------------------------------------------------------ |
| DB_TRX_ID   | 最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。 |
| DB_ROLL_PTR | 回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本。 |
| DB_ROW_ID   | 隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。       |

**Undo Log版本链**

![截屏2023-04-22 20.38.54](./image/MySQL-进阶篇/截屏2023-04-22 20.38.54.png)

最终我们发现，不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。

**ReadView**

ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。

ReadView中包含了四个核心字段：

| 字段           | 含义                                                 |
| -------------- | ---------------------------------------------------- |
| m_ids          | 当前活跃的事务ID集合                                 |
| min_trx_id     | 最小活跃事务ID                                       |
| max_trx_id     | 预分配事务ID，当前最大事务ID+1（因为事务ID是自增的） |
| creator_trx_id | ReadView创建者的事务ID                               |

而在Readiew中就规定了版本链数据的访问规则：

trx_id 代表当前undolog版本链对应事务ID。

| 条件                               | 能否访问                                  | 说明                                         |
| ---------------------------------- | ----------------------------------------- | -------------------------------------------- |
| trx_id == creatro_trx_id           | 可以访问该版本                            | 成立，说明数据是当前这个事务更改的。         |
| trx_id < min_trx_id                | 可以访问该版本                            | 成立，说明数据已经提交了。                   |
| trx_id > max_trx_id                | 不可以访问该版本                          | 成立，说明该事务是在ReadView生成后才开启的。 |
| min_trx_id <= trx_id <= max_trx_id | 如果trx_id不在m_ids中，那么可以访问该版本 | 成立，说明数据已经提交。                     |

不同的隔离级别，生成ReadView的时机不同：

- READ COMMITTED：在事务中每一次执行快照读的时候生成ReadView。
- REPEATABLE READ：只在事务第一次执行快照读的时候生成ReadView，后续重复使用该ReadView。















